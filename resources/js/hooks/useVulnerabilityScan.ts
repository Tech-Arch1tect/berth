import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { usePage } from '@inertiajs/react';
import { VulnerabilityScanService } from '../services/vulnerabilityScanService';
import {
  ImageScan,
  VulnerabilitySummary,
  LatestScanResponse,
  ScanWithSummary,
  ScanComparison,
  ScanTrendResponse,
} from '../types/vulnerability';

interface UseLatestVulnerabilityScanOptions {
  serverid: number;
  stackname: string;
  enabled?: boolean;
}

export function useLatestVulnerabilityScan({
  serverid,
  stackname,
  enabled = true,
}: UseLatestVulnerabilityScanOptions) {
  const { props } = usePage();
  const csrfToken = props.csrfToken as string | undefined;

  return useQuery<LatestScanResponse, Error>({
    queryKey: ['vulnerability-scan', 'latest', serverid, stackname],
    queryFn: () => VulnerabilityScanService.getLatestScan(serverid, stackname, csrfToken),
    enabled: enabled && !!serverid && !!stackname,
    staleTime: 30 * 1000,
    gcTime: 5 * 60 * 1000,
    refetchOnWindowFocus: false,
    retry: 1,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

interface UseVulnerabilityScanHistoryOptions {
  serverid: number;
  stackname: string;
  enabled?: boolean;
}

export function useVulnerabilityScanHistory({
  serverid,
  stackname,
  enabled = true,
}: UseVulnerabilityScanHistoryOptions) {
  const { props } = usePage();
  const csrfToken = props.csrfToken as string | undefined;

  return useQuery<ScanWithSummary[], Error>({
    queryKey: ['vulnerability-scan', 'history', serverid, stackname],
    queryFn: () => VulnerabilityScanService.getScanHistory(serverid, stackname, csrfToken),
    enabled: enabled && !!serverid && !!stackname,
    staleTime: 30 * 1000,
    gcTime: 5 * 60 * 1000,
    refetchOnWindowFocus: false,
    retry: 1,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

interface UseVulnerabilityScanOptions {
  scanid: number;
  enabled?: boolean;
}

export function useVulnerabilityScan({ scanid, enabled = true }: UseVulnerabilityScanOptions) {
  const { props } = usePage();
  const csrfToken = props.csrfToken as string | undefined;

  return useQuery<ImageScan, Error>({
    queryKey: ['vulnerability-scan', scanid],
    queryFn: () => VulnerabilityScanService.getScan(scanid, csrfToken),
    enabled: enabled && !!scanid,
    staleTime: 30 * 1000,
    gcTime: 5 * 60 * 1000,
    refetchOnWindowFocus: false,
    retry: 1,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

interface UseVulnerabilityScanSummaryOptions {
  scanid: number;
  enabled?: boolean;
}

export function useVulnerabilityScanSummary({
  scanid,
  enabled = true,
}: UseVulnerabilityScanSummaryOptions) {
  const { props } = usePage();
  const csrfToken = props.csrfToken as string | undefined;

  return useQuery<VulnerabilitySummary, Error>({
    queryKey: ['vulnerability-scan', 'summary', scanid],
    queryFn: () => VulnerabilityScanService.getScanSummary(scanid, csrfToken),
    enabled: enabled && !!scanid,
    staleTime: 30 * 1000,
    gcTime: 5 * 60 * 1000,
    refetchOnWindowFocus: false,
    retry: 1,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}

interface UseStartVulnerabilityScanOptions {
  serverid: number;
  stackname: string;
  onSuccess?: (scan: ImageScan) => void;
  onError?: (error: Error) => void;
}

interface StartScanVariables {
  services?: string[];
}

export function useStartVulnerabilityScan({
  serverid,
  stackname,
  onSuccess,
  onError,
}: UseStartVulnerabilityScanOptions) {
  const { props } = usePage();
  const csrfToken = props.csrfToken as string | undefined;
  const queryClient = useQueryClient();

  return useMutation<ImageScan, Error, StartScanVariables | void>({
    mutationFn: (variables) => {
      const services = variables?.services;
      return VulnerabilityScanService.startScan(serverid, stackname, services, csrfToken);
    },
    onSuccess: (scan) => {
      queryClient.invalidateQueries({
        queryKey: ['vulnerability-scan', 'latest', serverid, stackname],
      });
      queryClient.invalidateQueries({
        queryKey: ['vulnerability-scan', 'history', serverid, stackname],
      });
      onSuccess?.(scan);
    },
    onError: (error) => {
      onError?.(error);
    },
  });
}

interface UseScanComparisonOptions {
  baseScanId: number;
  compareScanId: number;
  enabled?: boolean;
}

export function useScanComparison({
  baseScanId,
  compareScanId,
  enabled = true,
}: UseScanComparisonOptions) {
  const { props } = usePage();
  const csrfToken = props.csrfToken as string | undefined;

  return useQuery<ScanComparison, Error>({
    queryKey: ['vulnerability-scan', 'compare', baseScanId, compareScanId],
    queryFn: () => VulnerabilityScanService.compareScans(baseScanId, compareScanId, csrfToken),
    enabled: enabled && !!baseScanId && !!compareScanId,
    staleTime: 5 * 60 * 1000,
    gcTime: 10 * 60 * 1000,
    refetchOnWindowFocus: false,
    retry: 1,
  });
}

interface UseScanTrendOptions {
  serverid: number;
  stackname: string;
  limit?: number;
  enabled?: boolean;
}

export function useScanTrend({
  serverid,
  stackname,
  limit = 10,
  enabled = true,
}: UseScanTrendOptions) {
  const { props } = usePage();
  const csrfToken = props.csrfToken as string | undefined;

  return useQuery<ScanTrendResponse, Error>({
    queryKey: ['vulnerability-scan', 'trend', serverid, stackname, limit],
    queryFn: () => VulnerabilityScanService.getScanTrend(serverid, stackname, limit, csrfToken),
    enabled: enabled && !!serverid && !!stackname,
    staleTime: 5 * 60 * 1000,
    gcTime: 10 * 60 * 1000,
    refetchOnWindowFocus: false,
    retry: 1,
  });
}
